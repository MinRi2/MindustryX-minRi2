From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Anuken <arnukren@gmail.com>
Date: Sun, 27 Jul 2025 16:49:25 -0400
Subject: [PATCH] Colored tile undo/fill support

---
 core/src/mindustry/editor/DrawOperation.java | 34 +++++++++++++++-----
 core/src/mindustry/editor/EditorTool.java    | 17 +++++++++-
 core/src/mindustry/editor/MapEditor.java     |  5 +++
 3 files changed, 47 insertions(+), 9 deletions(-)

diff --git a/core/src/mindustry/editor/DrawOperation.java b/core/src/mindustry/editor/DrawOperation.java
index 6fbf9b996d25705dd85c1cbba17bd7e10f18355a..382ff93f06ff12ac3114a33af8e54c2d8ddcaccd 100755
--- a/core/src/mindustry/editor/DrawOperation.java
+++ b/core/src/mindustry/editor/DrawOperation.java
@@ -15,7 +15,9 @@ public class DrawOperation{
     opBlock = 1,
     opRotation = 2,
     opTeam = 3,
-    opOverlay = 4;
+    opOverlay = 4,
+    opData = 5, //overlay/floor/data field
+    opDataExtra = 6; //extraData
 
     private LongSeq array = new LongSeq();
 
@@ -45,18 +47,20 @@ public class DrawOperation{
         setTile(editor.tile(TileOp.x(l), TileOp.y(l)), TileOp.type(l), TileOp.value(l));
     }
 
-    short getTile(Tile tile, byte type){
+    int getTile(Tile tile, int type){
         return switch(type){
             case opFloor -> tile.floorID();
             case opOverlay -> tile.overlayID();
             case opBlock -> tile.blockID();
             case opRotation -> tile.build == null ? 0 : (byte)tile.build.rotation;
-            case opTeam -> (byte)tile.getTeamID();
+            case opTeam -> tile.getTeamID();
+            case opData -> TileOpData.get(tile.data, tile.floorData, tile.overlayData);
+            case opDataExtra -> tile.extraData;
             default -> throw new IllegalArgumentException("Invalid type.");
         };
     }
 
-    void setTile(Tile tile, byte type, short to){
+    void setTile(Tile tile, int type, int to){
         if(type == opBlock || type == opTeam || type == opRotation){
             tile.getLinkedTiles(t -> {
                 editor.renderer.updateBlock(t);
@@ -89,6 +93,12 @@ public class DrawOperation{
                     if(tile.build != null) tile.build.rotation = to;
                 }
                 case opTeam -> tile.setTeam(Team.get(to));
+                case opData -> {
+                    tile.data = TileOpData.data(to);
+                    tile.floorData = TileOpData.floorData(to);
+                    tile.overlayData = TileOpData.overlayData(to);
+                }
+                case opDataExtra -> tile.extraData = to;
             }
         });
 
@@ -102,9 +112,17 @@ public class DrawOperation{
 
     @Struct
     class TileOpStruct{
-        short x;
-        short y;
-        byte type;
-        short value;
+        @StructField(14)
+        int x;
+        @StructField(14)
+        int y;
+        @StructField(3)
+        int type;
+        int value;
+    }
+
+    @Struct
+    class TileOpDataStruct{
+        byte data, floorData, overlayData;
     }
 }
diff --git a/core/src/mindustry/editor/EditorTool.java b/core/src/mindustry/editor/EditorTool.java
index cb15f6a7c70fdd0044bc47af2ee476b34f561113..67f902fa68623997666b82e2805bf28585f67db9 100644
--- a/core/src/mindustry/editor/EditorTool.java
+++ b/core/src/mindustry/editor/EditorTool.java
@@ -8,6 +8,7 @@ import arc.struct.*;
 import arc.util.*;
 import mindustry.content.*;
 import mindustry.game.*;
+import mindustry.gen.*;
 import mindustry.world.*;
 
 import static mindustry.Vars.*;
@@ -46,7 +47,6 @@ public enum EditorTool{
             });
         }
     },
-    //the "under liquid" rendering is too buggy to make public
     pencil(KeyCode.b, "replace", "square", "drawteams", "underliquid"){
         {
             edit = true;
@@ -139,6 +139,21 @@ public enum EditorTool{
                     setter = t -> t.setBlock(editor.drawBlock, editor.drawTeam);
                 }
 
+                var oldSetter = setter;
+                setter = t -> {
+                    if(editor.drawBlock.saveData){
+                        editor.addTileOp(TileOp.get(t.x, t.y, DrawOperation.opData, TileOpData.get(t.data, t.floorData, t.overlayData)));
+                        editor.addTileOp(TileOp.get(t.x, t.y, DrawOperation.opDataExtra, t.extraData));
+                    }
+
+                    oldSetter.get(t);
+
+                    if(!editor.drawBlock.synthetic() && editor.drawBlock.saveConfig){
+                        editor.drawBlock.placeEnded(t, null, editor.rotation, editor.drawBlock.lastConfig);
+                        editor.renderer.updateStatic(t.x, t.y);
+                    }
+                };
+
                 //replace only when the mode is 0 using the specified functions
                 fill(x, y, mode == 0, tester, setter);
             }else if(mode == 1){ //mode 1 is team fill
diff --git a/core/src/mindustry/editor/MapEditor.java b/core/src/mindustry/editor/MapEditor.java
index 610cd42eb9d07baccf8d70d82d95a11faffbee19..45b37c271a68e1218193b72330f1738215d734b3 100644
--- a/core/src/mindustry/editor/MapEditor.java
+++ b/core/src/mindustry/editor/MapEditor.java
@@ -157,6 +157,11 @@ public class MapEditor{
                 if(!tester.get(tile)) return;
                 boolean changed = false;
 
+                if(drawBlock.saveData){
+                    addTileOp(TileOp.get(tile.x, tile.y, DrawOperation.opData, TileOpData.get(tile.data, tile.floorData, tile.overlayData)));
+                    addTileOp(TileOp.get(tile.x, tile.y, DrawOperation.opDataExtra, tile.extraData));
+                }
+
                 if(isFloor){
                     if(forceOverlay){
                         tile.setOverlay(drawBlock.asFloor());
