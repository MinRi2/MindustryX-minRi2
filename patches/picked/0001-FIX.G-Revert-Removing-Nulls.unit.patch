From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Tue, 23 Jul 2024 14:08:52 +0800
Subject: [PATCH] FIX.G: Revert "Removing Nulls.unit"

This reverts commit 29557314
---
 .../annotations/entity/EntityProcess.java     | 83 +++++++++++++++++++
 .../mindustry/entities/comp/PlayerComp.java   |  2 +
 core/src/mindustry/input/InputHandler.java    |  2 +-
 core/src/mindustry/logic/LExecutor.java       |  2 +-
 4 files changed, 87 insertions(+), 2 deletions(-)

diff --git a/annotations/src/main/java/mindustry/annotations/entity/EntityProcess.java b/annotations/src/main/java/mindustry/annotations/entity/EntityProcess.java
index 3abd583158111d34ab1ca7a7126b7126bdbd5d4f..3fa62d844643147aba65a54b4d5f67d39d1c57ff 100644
--- a/annotations/src/main/java/mindustry/annotations/entity/EntityProcess.java
+++ b/annotations/src/main/java/mindustry/annotations/entity/EntityProcess.java
@@ -851,6 +851,89 @@ public class EntityProcess extends BaseProcessor{
             for(TypeSpec.Builder b : baseClasses){
                 write(b, imports.toSeq());
             }
+
+            //TODO nulls were an awful idea
+            //store nulls
+            TypeSpec.Builder nullsBuilder = TypeSpec.classBuilder("Nulls").addModifiers(Modifier.PUBLIC).addModifiers(Modifier.FINAL);
+            //TODO should be dynamic
+            ObjectSet<String> nullList = ObjectSet.with("unit");
+
+            //create mock types of all components
+            for(Stype interf : allInterfaces){
+                //indirect interfaces to implement methods for
+                Seq<Stype> dependencies = interf.allInterfaces().add(interf);
+                Seq<Smethod> methods = dependencies.flatMap(Stype::methods);
+                methods.sortComparing(Object::toString);
+
+                //optionally add superclass
+                Stype superclass = dependencies.map(this::interfaceToComp).find(s -> s != null && s.annotation(Component.class).base());
+                //use the base type when the interface being emulated has a base
+                TypeName type = superclass != null && interfaceToComp(interf).annotation(Component.class).base() ? tname(baseName(superclass)) : interf.tname();
+
+                //used method signatures
+                ObjectSet<String> signatures = new ObjectSet<>();
+
+                //create null builder
+                String baseName = interf.name().substring(0, interf.name().length() - 1);
+
+                //prevent Nulls bloat
+                if(!nullList.contains(Strings.camelize(baseName))){
+                    continue;
+                }
+
+                String className = "Null" + baseName;
+                TypeSpec.Builder nullBuilder = TypeSpec.classBuilder(className)
+                .addModifiers(Modifier.FINAL);
+
+                skipDeprecated(nullBuilder);
+
+                nullBuilder.addSuperinterface(interf.tname());
+                if(superclass != null) nullBuilder.superclass(tname(baseName(superclass)));
+
+                for(Smethod method : methods){
+                    String signature = method.toString();
+                    if(!signatures.add(signature)) continue;
+
+                    Stype compType = interfaceToComp(method.type());
+                    MethodSpec.Builder builder = MethodSpec.overriding(method.e).addModifiers(Modifier.PUBLIC, Modifier.FINAL);
+                    int index = 0;
+                    for(ParameterSpec spec : builder.parameters){
+                        Reflect.set(spec, "name",  "arg" + index++);
+                    }
+                    builder.addAnnotation(OverrideCallSuper.class); //just in case
+
+                    if(!method.isVoid()){
+                        String methodName = method.name();
+                        switch(methodName){
+                            case "isNull":
+                                builder.addStatement("return true");
+                                break;
+                            case "id":
+                                builder.addStatement("return -1");
+                                break;
+                            case "toString":
+                                builder.addStatement("return $S", className);
+                                break;
+                            default:
+                                Svar variable = compType == null || method.params().size > 0 ? null : compType.fields().find(v -> v.name().equals(methodName));
+                                String desc = variable == null ? null : variable.descString();
+                                if(variable == null || !varInitializers.containsKey(desc)){
+                                    builder.addStatement("return " + getDefault(method.ret().toString()));
+                                }else{
+                                    String init = varInitializers.get(desc);
+                                    builder.addStatement("return " + (init.equals("{}") ? "new " + variable.mirror().toString() : "") + init);
+                                }
+                        }
+                    }
+                    nullBuilder.addMethod(builder.build());
+                }
+
+                nullsBuilder.addField(FieldSpec.builder(type, Strings.camelize(baseName)).initializer("new " + className + "()").addModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PUBLIC).build());
+
+                write(nullBuilder, imports.toSeq());
+            }
+
+            write(nullsBuilder);
         }
     }
 
diff --git a/core/src/mindustry/entities/comp/PlayerComp.java b/core/src/mindustry/entities/comp/PlayerComp.java
index 834d4c239aa261afd9828f0b4d17a97fb8809621..7f989fa8dfb2f6c9c2b1c0e7c88bf9030f882c21 100644
--- a/core/src/mindustry/entities/comp/PlayerComp.java
+++ b/core/src/mindustry/entities/comp/PlayerComp.java
@@ -202,10 +202,12 @@ abstract class PlayerComp implements UnitController, Entityc, Syncc, Timerc, Dra
     }
 
     public @Nullable Unit unit(){
+        if(unit == null) return Nulls.unit;
         return unit;
     }
 
     public void unit(@Nullable Unit unit){
+        if(unit == Nulls.unit) unit = null;
         //refuse to switch when the unit was just transitioned from
         if(isLocal() && unit == justSwitchFrom && justSwitchFrom != null && justSwitchTo != null){
             return;
diff --git a/core/src/mindustry/input/InputHandler.java b/core/src/mindustry/input/InputHandler.java
index bae5d3806df2f432c987b2cf21d4329dd4557206..ad309cfb0b24988965ff43febd972a8ed7cca1cc 100644
--- a/core/src/mindustry/input/InputHandler.java
+++ b/core/src/mindustry/input/InputHandler.java
@@ -695,7 +695,7 @@ public abstract class InputHandler implements InputProcessor, GestureListener{
 
             player.unit(unit);
 
-            if(before != null){
+            if(before != null && before != Nulls.unit){
                 if(before.spawnedByCore){
                     unit.dockedType = before.type;
                 }else if(before.dockedType != null && before.dockedType.coreUnitDock){
diff --git a/core/src/mindustry/logic/LExecutor.java b/core/src/mindustry/logic/LExecutor.java
index e74d4134affd4e040f14d42b2f74738eb6344cce..6654fd9e96b7015b5ef74b9ee9746a22787fe911 100644
--- a/core/src/mindustry/logic/LExecutor.java
+++ b/core/src/mindustry/logic/LExecutor.java
@@ -1241,7 +1241,7 @@ public class LExecutor{
                         result.setobj(units == null || i < 0 || i >= units.size ? null : units.get(i));
                     }
                 }
-                case player -> result.setobj(i < 0 || i >= data.players.size ? null :
+                case player -> result.setobj(i < 0 || i >= data.players.size || data.players.get(i).dead() ? null :
                     data.players.get(i).unit() instanceof BlockUnitc block ? block.tile() : data.players.get(i).unit());
                 case core -> result.setobj(i < 0 || i >= data.cores.size ? null : data.cores.get(i));
                 case build -> {
