From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: way-zer <himc.wicp@gmail.com>
Date: Thu, 25 Apr 2024 14:49:41 +0800
Subject: [PATCH] =?UTF-8?q?OC:=20=E4=BC=98=E5=8C=96Batch=E6=80=A7=E8=83=BD?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

大幅优化渲染性能
UPDATE1: 增加配置项，默认关闭
UPDATE2: 优化性能；我真的已经尽力了，剩下的只能怪java慢了
UPDATE3: 完全重写了sort，又提升了一倍sort性能
UPDATE4: 修复一些bug，并优化性能。这次重写了IntIntMap。(排序算法相当于完全重写完了)
UPDATE5: 修复文字渲染错误

sorted不写回，减少开销。
way-zer <himc.wicp@gmail.com> on 2024/5/28

新功能：顶点合并
way-zer <himc.wicp@gmail.com> on 2024/7/23

顶点合并等优化已合并到arc上游
way-zer <himc.wicp@gmail.com> on 2024/8/4
---
 core/src/arc/graphics/g2d/MySpriteBatch.java  | 230 ++++++++++++++++++
 core/src/mindustry/graphics/MultiPacker.java  |   2 +-
 .../world/blocks/logic/LogicDisplay.java      | 174 +++++++------
 3 files changed, 315 insertions(+), 91 deletions(-)

diff --git a/core/src/arc/graphics/g2d/MySpriteBatch.java b/core/src/arc/graphics/g2d/MySpriteBatch.java
index e2bdb30e190a210f25130c423c853892798e4c28..97228b7fadd15f0491a50849bfb19f4f3ced8bb6 100644
--- a/core/src/arc/graphics/g2d/MySpriteBatch.java
+++ b/core/src/arc/graphics/g2d/MySpriteBatch.java
@@ -1,10 +1,29 @@
 package arc.graphics.g2d;
 
 import arc.graphics.*;
+import arc.math.*;
 import mindustryX.features.*;
 
+import java.util.*;
+
 //MDTX: add some DebugUtil count.
+//MDTX(WayZer): renderSort
 public class MySpriteBatch extends SpriteBatch{
+    private static final boolean DEBUG = false;
+    private static final int PRIME1 = 0xbe1f14b1;
+    private static final int PRIME2 = 0xb4b82e39;
+    int[] extraZ = new int[10000];
+    //增加小的delta，来保持原来的前后顺序
+    int orderZ = 0;
+    int hashZ = 0;//打乱hash值，来检查渲染异常
+
+    @Override
+    protected void z(float z){
+        orderZ = 0;
+        if(this.z == z) return;
+        super.z(z);
+    }
+
     @Override
     protected void flush(){
         DebugUtil.lastFlushCount++;
@@ -23,4 +42,215 @@ public class MySpriteBatch extends SpriteBatch{
         DebugUtil.lastSwitchTexture++;
         super.switchTexture(texture);
     }
+
+    @Override
+    protected void expandRequests(){
+        super.expandRequests();
+        extraZ = Arrays.copyOf(extraZ, requestZ.length);
+    }
+
+    @Override
+    protected void draw(Texture texture, float[] spriteVertices, int offset, int count){
+        super.draw(texture, spriteVertices, offset, count);
+        if(sort && !flushing && RenderExt.renderSort){
+            int h = texture.hashCode();
+            if(DEBUG){
+                h = (h + hashZ) * PRIME1;
+                h = h ^ (h >>> 16);
+            }
+            extraZ[numRequests - 1] = ((orderZ++) << 16) | (h & 0xffff);
+        }
+    }
+
+    @Override
+    protected void draw(Runnable request){
+        super.draw(request);
+        if(sort && !flushing && RenderExt.renderSort){
+            int h = DEBUG ? hashZ : 0;
+            extraZ[numRequests - 1] = ((orderZ++) << 16) | (h & 0xffff);
+        }
+    }
+
+    @Override
+    protected void sortRequests(){
+        if(!RenderExt.renderSort){
+            super.sortRequests();
+            return;
+        }
+        hashZ = DEBUG ? Float.floatToIntBits((float)Math.random()) : 0;
+
+        int numRequests = this.numRequests;
+        int[] arr = this.requestZ, extraZ = this.extraZ;
+        sortMap(arr, numRequests);
+        sortMap(extraZ, numRequests);
+        for(int i = 0; i < numRequests; i++){
+            arr[i] = (arr[i] << 16) | extraZ[i];
+        }
+        countingSortMap(arr, numRequests);//arr is loc now;
+
+        if(copy.length < requests.length) copy = new DrawRequest[requests.length];
+        final DrawRequest[] items = requests, dest = copy;
+        for(int i = 0; i < numRequests; i++){
+            dest[arr[i]] = items[i];
+        }
+    }
+
+    private static final IntIntMap vMap = new IntIntMap(10000, 0.25f);
+    private static int[] orderArr = new int[1000], orderArr2 = new int[1000];
+
+    /**
+     * 将输入arr重映射到有序的[0,unique)域
+     * @param arr 待排序数组，输出会映射为id值
+     * @return unique
+     */
+    private static int sortMap(int[] arr, int len){
+        var map = vMap;
+        int[] order = orderArr;
+        map.clear();
+        int unique = 0;
+        for(int i = 0; i < len; i++){
+            int v = arr[i];
+            int id = map.getOrPut(v, unique);
+            arr[i] = id;//arr现在表示id
+            if(id == unique){
+                if(order.length <= unique){
+                    order = Arrays.copyOf(order, unique << 1);
+                }
+                order[unique] = v;
+                unique++;
+            }
+        }
+        orderArr = order;
+
+        //对z值排序
+        Arrays.sort(order, 0, unique);//order -> z
+
+        //arr中储存order
+        int[] order2 = orderArr2;//id -> order
+        if(order2.length < order.length){
+            order2 = orderArr2 = new int[order.length];
+        }
+        for(int i = 0; i < unique; i++){
+            order2[map.getOrPut(order[i], -1)] = i;
+        }
+        for(int i = 0; i < len; i++){
+            arr[i] = order2[arr[i]];
+        }
+        return unique;
+    }
+
+    /**
+     * 计数排序
+     * @param arr 待排序数组，输出为新loc
+     */
+    private static void countingSortMap(int[] arr, int len){
+        int[] order = orderArr, counts = orderArr2;
+        var map = vMap;//z->id
+        map.clear();
+        int unique = 0;
+        for(int i = 0; i < len; i++){
+            int v = arr[i];
+            int id = map.getOrPut(v, unique);
+            arr[i] = id;//arr现在表示id
+            if(id == unique){
+                if(unique >= counts.length){
+                    order = orderArr = Arrays.copyOf(order, unique << 1);
+                    counts = orderArr2 = Arrays.copyOf(counts, unique << 1);
+                }
+                order[unique] = v;
+                counts[unique] = 1;
+                unique++;
+            }else counts[id]++;
+        }
+
+        //对z值排序
+        Arrays.sort(order, 0, unique);//order -> z
+
+        //将counts转换为locs(每个id起始位置)
+        for(int i = 0, loc = 0; i < unique; i++){
+            int id = map.getOrPut(order[i], -1);
+            int c = counts[id];
+            counts[id] = loc;
+            loc += c;
+        }
+        //arr现在表示新目的地
+        for(int i = 0; i < len; i++){
+            arr[i] = counts[arr[i]]++;
+        }
+    }
+
+    static public class IntIntMap{
+        private int[] keys;
+        private boolean hasZero;
+        private int[] values;
+        private int zeroValue;
+        private int size; // 哈希表中的元素数量
+
+        private int capacity, maxSize;
+        private float loadFactor;
+        private int mask, hashShift;
+
+        public IntIntMap(int capacity, float loadFactor){
+            setCapacity(capacity, loadFactor);
+        }
+
+        private int hash(int key){
+            key *= PRIME2;
+            return (key ^ key >>> hashShift);
+        }
+
+        public int getOrPut(int key, int defaultValue){
+            if(key == 0){
+                if(hasZero) return zeroValue;
+                zeroValue = defaultValue;
+                hasZero = true;
+                return defaultValue;
+            }
+            int mask = this.mask;
+            int index = hash(key) & mask;
+            int[] keys = this.keys;
+            while(keys[index] != 0){
+                if(keys[index] == key){// 键找到
+                    return values[index];
+                }
+                index = (index + 1) & mask;
+            }
+            //键不存在
+            keys[index] = key;
+            values[index] = defaultValue;
+            size++;
+            if(size > maxSize) setCapacity(capacity << 1, loadFactor);
+            return defaultValue;
+        }
+
+        private void setCapacity(int capacity, float loadFactor){
+            capacity = Mathf.nextPowerOfTwo(capacity);
+            this.capacity = capacity;
+            this.loadFactor = loadFactor;
+            maxSize = (int)(capacity * loadFactor);
+            int mask = this.mask = capacity - 1;
+            hashShift = 31 - Integer.numberOfTrailingZeros(capacity);
+
+            int[] oldKeys = keys, oldValues = values;
+            int[] keys = this.keys = new int[capacity];
+            int[] values = this.values = new int[capacity];
+            if(oldKeys == null || oldValues == null) return;
+            for(int i = 0; i < oldKeys.length; i++){
+                if(oldKeys[i] == 0) continue;
+                int index = hash(oldKeys[i]) & mask;
+                while(keys[index] != 0){
+                    index = (index + 1) & mask;
+                }
+                keys[index] = oldKeys[i];
+                values[index] = oldValues[i]; // 插入或更新值
+            }
+        }
+
+        private void clear(){
+            Arrays.fill(keys, 0);
+            Arrays.fill(values, 0);
+            size = 0;
+            hasZero = false;
+        }
+    }
 }
diff --git a/core/src/mindustry/graphics/MultiPacker.java b/core/src/mindustry/graphics/MultiPacker.java
index e5f473a7651495f7f61856e6df711fba12dfb1be..f1a3f1cbbac0fbda6dfabe689f25c2108ef58337 100644
--- a/core/src/mindustry/graphics/MultiPacker.java
+++ b/core/src/mindustry/graphics/MultiPacker.java
@@ -114,7 +114,7 @@ public class MultiPacker implements Disposable{
     //editor page (sprites5.png) - all sprites needed for rendering in the editor, including block icons and a few minor sprites
     public enum PageType{
         //main page can be massive, but 8192 throws GL_OUT_OF_MEMORY on some GPUs and I can't deal with it yet.
-        main(4096),
+        main(16384, 4096), //MDTX 更大图集
 
         //TODO stuff like this throws OOM on some devices
         environment(4096, 2048),
diff --git a/core/src/mindustry/world/blocks/logic/LogicDisplay.java b/core/src/mindustry/world/blocks/logic/LogicDisplay.java
index 1db6409a264c5977e4ccfbf7709d1db430ac31e6..c8794b047f0faccadd106edca05997af1f03c648 100644
--- a/core/src/mindustry/world/blocks/logic/LogicDisplay.java
+++ b/core/src/mindustry/world/blocks/logic/LogicDisplay.java
@@ -20,25 +20,25 @@ import mindustryX.features.*;
 
 public class LogicDisplay extends Block{
     public static final byte
-        commandClear = 0,
-        commandColor = 1,
-        //virtual command, unpacked in instruction
-        commandColorPack = 2,
-        commandStroke = 3,
-        commandLine = 4,
-        commandRect = 5,
-        commandLineRect = 6,
-        commandPoly = 7,
-        commandLinePoly = 8,
-        commandTriangle = 9,
-        commandImage = 10,
-        //note that this command actually only draws 1 character, unpacked in instruction
-        commandPrint = 11,
-
-        commandTranslate = 12,
-        commandScale = 13,
-        commandRotate = 14,
-        commandResetTransform = 15
+    commandClear = 0,
+    commandColor = 1,
+    //virtual command, unpacked in instruction
+    commandColorPack = 2,
+    commandStroke = 3,
+    commandLine = 4,
+    commandRect = 5,
+    commandLineRect = 6,
+    commandPoly = 7,
+    commandLinePoly = 8,
+    commandTriangle = 9,
+    commandImage = 10,
+    //note that this command actually only draws 1 character, unpacked in instruction
+    commandPrint = 11,
+
+    commandTranslate = 12,
+    commandScale = 13,
+    commandRotate = 14,
+    commandResetTransform = 15
     ;
 
     public static final float scaleStep = 0.05f;
@@ -78,89 +78,83 @@ public class LogicDisplay extends Block{
 
             //don't even bother processing anything when displays are off.
             if(!Vars.renderer.drawDisplays) return;
+            Draw.draw(Draw.z(), this::draw0);
+        }
 
-            Draw.draw(Draw.z(), () -> {
-                if(buffer == null){
-                    buffer = new FrameBuffer(displaySize, displaySize);
-                    //clear the buffer - some OSs leave garbage in it
-                    buffer.begin(Pal.darkerMetal);
-                    buffer.end();
-                }
-            });
+        private void draw0(){
+            if(buffer == null){
+                buffer = new FrameBuffer(displaySize, displaySize);
+                //clear the buffer - some OSs leave garbage in it
+                buffer.begin(Pal.darkerMetal);
+                buffer.end();
+            }
 
             //don't bother processing commands if displays are off
             if(!commands.isEmpty()){
-                Draw.draw(Draw.z(), () -> {
-                    Tmp.m1.set(Draw.proj());
-                    Tmp.m2.set(Draw.trans());
-                    Draw.proj(0, 0, displaySize, displaySize);
-                    if(transform != null){
-                        Draw.trans(transform);
-                    }
-                    buffer.begin();
-                    Draw.color(color);
-                    Lines.stroke(stroke);
-
-                    while(!commands.isEmpty()){
-                        long c = commands.removeFirst();
-                        int type = DisplayCmd.type(c);
-                        int x = unpackSign(DisplayCmd.x(c)), y = unpackSign(DisplayCmd.y(c)),
-                        p1 = unpackSign(DisplayCmd.p1(c)), p2 = unpackSign(DisplayCmd.p2(c)), p3 = unpackSign(DisplayCmd.p3(c)), p4 = unpackSign(DisplayCmd.p4(c));
-
-                        switch(type){
-                            case commandClear -> {
-                                //discard any pending batched sprites, so they don't get drawn over the cleared screen later
-                                Draw.discard();
-                                Core.graphics.clear(x / 255f, y / 255f, p1 / 255f, 1f);
-                            }
-                            case commandLine -> Lines.line(x, y, p1, p2);
-                            case commandRect -> Fill.crect(x, y, p1, p2);
-                            case commandLineRect -> Lines.rect(x, y, p1, p2);
-                            case commandPoly -> Fill.poly(x, y, Math.min(p1, maxSides), p2, p3);
-                            case commandLinePoly -> Lines.poly(x, y, Math.min(p1, maxSides), p2, p3);
-                            case commandTriangle -> Fill.tri(x, y, p1, p2, p3, p4);
-                            case commandColor -> Draw.color(this.color = Color.toFloatBits(x, y, p1, p2));
-                            case commandStroke -> Lines.stroke(this.stroke = x);
-                            case commandImage -> {
-                                if(p4 >= 0 && p4 < ContentType.all.length && Vars.content.getByID(ContentType.all[p4], p1) instanceof UnlockableContent u){
-                                    var icon = u.fullIcon;
-                                    Draw.rect(icon, x, y, p2, p2 / icon.ratio(), p3);
-                                }
+                Tmp.m1.set(Draw.proj());
+                Tmp.m2.set(Draw.trans());
+                Draw.proj(0, 0, displaySize, displaySize);
+                if(transform != null){
+                    Draw.trans(transform);
+                }
+                buffer.begin();
+                Draw.color(color);
+                Lines.stroke(stroke);
+
+                while(!commands.isEmpty()){
+                    long c = commands.removeFirst();
+                    int type = DisplayCmd.type(c);
+                    int x = unpackSign(DisplayCmd.x(c)), y = unpackSign(DisplayCmd.y(c)),
+                    p1 = unpackSign(DisplayCmd.p1(c)), p2 = unpackSign(DisplayCmd.p2(c)), p3 = unpackSign(DisplayCmd.p3(c)), p4 = unpackSign(DisplayCmd.p4(c));
+
+                    switch(type){
+                        case commandClear -> {
+                            //discard any pending batched sprites, so they don't get drawn over the cleared screen later
+                            Draw.discard();
+                            Core.graphics.clear(x / 255f, y / 255f, p1 / 255f, 1f);
+                        }
+                        case commandLine -> Lines.line(x, y, p1, p2);
+                        case commandRect -> Fill.crect(x, y, p1, p2);
+                        case commandLineRect -> Lines.rect(x, y, p1, p2);
+                        case commandPoly -> Fill.poly(x, y, Math.min(p1, maxSides), p2, p3);
+                        case commandLinePoly -> Lines.poly(x, y, Math.min(p1, maxSides), p2, p3);
+                        case commandTriangle -> Fill.tri(x, y, p1, p2, p3, p4);
+                        case commandColor -> Draw.color(this.color = Color.toFloatBits(x, y, p1, p2));
+                        case commandStroke -> Lines.stroke(this.stroke = x);
+                        case commandImage -> {
+                            if(p4 >= 0 && p4 < ContentType.all.length && Vars.content.getByID(ContentType.all[p4], p1) instanceof UnlockableContent u){
+                                var icon = u.fullIcon;
+                                Draw.rect(icon, x, y, p2, p2 / icon.ratio(), p3);
                             }
-                            case commandPrint -> {
-                                var glyph = Fonts.logic.getData().getGlyph((char)p1);
-                                if(glyph != null){
-                                    Tmp.tr1.set(Fonts.logic.getRegion().texture);
-                                    Tmp.tr1.set(glyph.u, glyph.v2, glyph.u2, glyph.v);
-
-                                    Draw.rect(Tmp.tr1, x + Tmp.tr1.width/2f + glyph.xoffset, y + Tmp.tr1.height/2f + glyph.yoffset + Fonts.logic.getData().capHeight + Fonts.logic.getData().ascent, Tmp.tr1.width, Tmp.tr1.height);
-                                }
+                        }
+                        case commandPrint -> {
+                            var glyph = Fonts.logic.getData().getGlyph((char)p1);
+                            if(glyph != null){
+                                Tmp.tr1.set(Fonts.logic.getRegion().texture);
+                                Tmp.tr1.set(glyph.u, glyph.v2, glyph.u2, glyph.v);
+
+                                Draw.rect(Tmp.tr1, x + Tmp.tr1.width / 2f + glyph.xoffset, y + Tmp.tr1.height / 2f + glyph.yoffset + Fonts.logic.getData().capHeight + Fonts.logic.getData().ascent, Tmp.tr1.width, Tmp.tr1.height);
                             }
-                            case commandTranslate -> Draw.trans((transform == null ? (transform = new Mat()) : transform).translate(x, y));
-                            case commandScale -> Draw.trans((transform == null ? (transform = new Mat()) : transform).scale(x * scaleStep, y * scaleStep));
-                            case commandRotate-> Draw.trans((transform == null ? (transform = new Mat()) : transform).rotate(p1));
-                            case commandResetTransform -> Draw.trans((transform == null ? (transform = new Mat()) : transform).idt());
                         }
+                        case commandTranslate -> Draw.trans((transform == null ? (transform = new Mat()) : transform).translate(x, y));
+                        case commandScale -> Draw.trans((transform == null ? (transform = new Mat()) : transform).scale(x * scaleStep, y * scaleStep));
+                        case commandRotate -> Draw.trans((transform == null ? (transform = new Mat()) : transform).rotate(p1));
+                        case commandResetTransform -> Draw.trans((transform == null ? (transform = new Mat()) : transform).idt());
                     }
+                }
 
-                    buffer.end();
-                    Draw.proj(Tmp.m1);
-                    Draw.trans(Tmp.m2);
-                    Draw.reset();
-                });
+                buffer.end();
+                Draw.proj(Tmp.m1);
+                Draw.trans(Tmp.m2);
+                Draw.reset();
             }
 
             Draw.blend(Blending.disabled);
-            Draw.draw(Draw.z(), () -> {
-                if(buffer != null){
-                    if(RenderExt.logicDisplayNoBorder){
-                        Draw.rect(Draw.wrap(buffer.getTexture()), x, y, (buffer.getWidth() + 16) * Draw.scl, -(buffer.getHeight() + 16) * Draw.scl);
-                        return;
-                    }
-                    Draw.rect(Draw.wrap(buffer.getTexture()), x, y, buffer.getWidth() * scaleFactor * Draw.scl, -buffer.getHeight() * scaleFactor * Draw.scl);
-                }
-            });
-            Draw.blend();
+            if(RenderExt.logicDisplayNoBorder){
+                Draw.rect(Draw.wrap(buffer.getTexture()), x, y, (buffer.getWidth() + 16) * Draw.scl, -(buffer.getHeight() + 16) * Draw.scl);
+                return;
+            }
+            Draw.rect(Draw.wrap(buffer.getTexture()), x, y, buffer.getWidth() * scaleFactor * Draw.scl, -buffer.getHeight() * scaleFactor * Draw.scl);
         }
 
         @Override
